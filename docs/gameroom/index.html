<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游戏实验室 | DawnTilDusk</title>
    <!-- 引入 Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 引入主样式表 (复用背景和基础风格) -->
    <link rel="stylesheet" href="../styles.css">
    <style>
        /* 页面特定样式 */
        body {
            overflow: hidden; /* 防止滚动条出现 */
        }

        /* 游戏容器：占据剩余空间 */
        #game-playground {
            position: relative;
            width: 100%;
            height: calc(100vh - 180px); /* 减去Header和Footer的大致高度 */
            margin-top: 20px;
            /* 可选：给容器加一个极其微弱的边框或背景，让它看起来像个“池子” */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        /* 浮动方块样式 */
        .game-block {
            position: absolute;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7); /* 默认文字颜色较暗 */
            background: rgba(255, 255, 255, 0.05); /* 默认背景非常透明 */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(4px);
            transition: background 0.3s, color 0.3s, box-shadow 0.1s, transform 0.1s;
            cursor: pointer;
            user-select: none;
            text-align: center;
            padding: 10px;
        }

        .game-block i {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .game-block span {
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* 鼠标悬停效果 (用户主动交互) - 保持与其他高光时刻一致 */
        .game-block:hover {
            background: rgba(255, 255, 255, 0.3); /* 稍微更亮一点 */
            border-color: rgba(255, 255, 255, 0.8);
            color: white;
            z-index: 100; /* 确保在最上层 */
            /* transform 由 JS 控制 */
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6); /* 强烈发光 */
        }

        .game-block:hover i {
            opacity: 1;
        }

        /* 碰撞发光效果 (JavaScript控制) */
        .game-block.hit-glow {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            color: white;
        }

        /* 适配移动端 */
        @media (max-width: 768px) {
            .game-block {
                width: 90px;
                height: 90px;
            }
            .game-block i {
                font-size: 1.5rem;
            }
            .game-block span {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="container-inner">
                <nav>
                    <!-- Logo链接回主页 -->
                    <a href="../index.html" class="logo">DawnTilDusk | 游戏实验室</a>
                    <ul class="nav-links">
                        <!-- 保持导航一致性，当前页高亮或不可点 -->
                        <li><a href="#" style="color: #efe8cb; border-bottom: 2px solid #efe8cb;">Games</a></li>
                        <li><a href="#">002</a></li>
                        <li><a href="#" id="easterEgg">003</a></li>
                        <li><a href="#">004</a></li>
                        <li><a href="#">005</a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <main>
            <!-- 游戏物理容器 -->
            <div id="game-playground">
                <!-- 方块将由JS动态生成 -->
            </div>
        </main>
    </div>

    <!-- 脚本逻辑 -->
    <script>
        // ================= 配置区域 =================
        // 在这里添加你的新游戏！
        const games = [
            {
                id: 'satire-runner',
                name: 'Satire Runner',
                icon: 'fa-person-running', // FontAwesome 图标名
                url: '../satire-runner/',   // 游戏链接
                color: '#4caf50'            // 暂时没用到，可用于特定发光色
            },
            // 示例：未来添加新游戏只需解开注释并修改
            {
                id: 'new-game',
                name: '超级新游戏',
                icon: 'fa-gamepad',
                url: '#',
                color: '#ff5722'
            },
        ];
        // ===========================================

        const playground = document.getElementById('game-playground');
        const blocks = [];

        // 初始化游戏方块
        function initBlocks() {
            const containerRect = playground.getBoundingClientRect();
            
            games.forEach((game, index) => {
                const el = document.createElement('a');
                el.href = game.url;
                el.className = 'game-block';
                el.innerHTML = `<i class="fas ${game.icon}"></i><span>${game.name}</span>`;
                
                playground.appendChild(el);

                // 随机初始位置 (避免贴边)
                // 注意：el.offsetWidth 在添加到DOM后才可用
                const w = 120; // 估算宽度，或在下一帧获取
                const h = 120;
                const maxX = containerRect.width - w;
                const maxY = containerRect.height - h;

                const x = Math.random() * (maxX - 20) + 10;
                const y = Math.random() * (maxY - 20) + 10;

                // 随机速度 (px/frame)
                // 速度范围：1 ~ 3
                const speed = 1.5; 
                const angle = Math.random() * Math.PI * 2;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;

                blocks.push({
                    el: el,
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy,
                    width: w,
                    height: h,
                    glowTimer: null,
                    isHovered: false // 新增状态
                });

                // 绑定鼠标事件
                el.addEventListener('mouseenter', () => {
                    const block = blocks[index]; // 闭包捕获
                    block.isHovered = true;
                    // 可选：悬停时暂停运动？或者只是跟随？
                    // 如果要暂停物理运动，可以在 animate 里判断
                });
                
                el.addEventListener('mouseleave', () => {
                     const block = blocks[index];
                     block.isHovered = false;
                });
            });
        }

        // 物理循环
        function animate() {
            const containerRect = playground.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;

            // 1. 更新所有非悬停方块的位置
            blocks.forEach(block => {
                if (!block.isHovered) {
                    block.x += block.dx;
                    block.y += block.dy;
                }
            });

            // 2. 方块间的碰撞检测 (双循环避免重复)
            for (let i = 0; i < blocks.length; i++) {
                for (let j = i + 1; j < blocks.length; j++) {
                    const b1 = blocks[i];
                    const b2 = blocks[j];

                    // 如果两个都被悬停，都不动，无需处理
                    if (b1.isHovered && b2.isHovered) continue;

                    // 简单的 AABB 碰撞检测 (轴对齐包围盒)
                    // 如果需要更精确的圆形碰撞（考虑到方块旋转视觉上可能像圆），可以用距离公式
                    // 这里我们用距离公式模拟“圆形”弹性碰撞，效果更自然
                    // 假设碰撞半径略小于方块宽度的一半 (60px)
                    const radius = 60; 
                    const dx = (b1.x + b1.width/2) - (b2.x + b2.width/2);
                    const dy = (b1.y + b1.height/2) - (b2.y + b2.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius * 2) {
                        // === 发生碰撞 ===
                        
                        // 1. 触发发光
                        triggerGlow(b1);
                        triggerGlow(b2);

                        // 2. 物理计算
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const overlap = radius * 2 - distance;

                        // 分情况处理质量
                        if (b1.isHovered) {
                            // b1 是墙 (无限质量)，b2 反弹
                            // 位置修正：只移 b2
                            b2.x -= nx * overlap;
                            b2.y -= ny * overlap;

                            // 速度反射：v2' = v2 - 2 * dot(v2, n) * n
                            // 注意：这里的法线 n 是从 b2 指向 b1 的反方向，或者直接用上面的 nx, ny (从 b2 指向 b1 是 -nx, -ny)
                            // 让我们简单点：相对速度 v_rel = v2 - v1(0) = v2
                            // 碰撞冲量仅作用于 b2
                            // 镜面反射公式
                            const dot = b2.dx * nx + b2.dy * ny;
                            b2.dx -= 2 * dot * nx;
                            b2.dy -= 2 * dot * ny;

                        } else if (b2.isHovered) {
                            // b2 是墙 (无限质量)，b1 反弹
                            // 位置修正：只移 b1
                            b1.x += nx * overlap;
                            b1.y += ny * overlap;

                            // 速度反射
                            const dot = b1.dx * nx + b1.dy * ny;
                            b1.dx -= 2 * dot * nx;
                            b1.dy -= 2 * dot * ny;

                        } else {
                            // 双方都是普通质量 (完全弹性碰撞)
                            
                            // 分离重叠部分 (各退一半)
                            const separationX = nx * overlap * 0.5;
                            const separationY = ny * overlap * 0.5;
                            
                            b1.x += separationX;
                            b1.y += separationY;
                            b2.x -= separationX;
                            b2.y -= separationY;

                            // 交换法线方向的速度分量
                            const dvx = b1.dx - b2.dx;
                            const dvy = b1.dy - b2.dy;
                            const dotProduct = dvx * nx + dvy * ny;

                            // 只有当它们相互靠近时才反弹
                            if (dotProduct < 0) {
                                b1.dx -= dotProduct * nx;
                                b1.dy -= dotProduct * ny;
                                b2.dx += dotProduct * nx;
                                b2.dy += dotProduct * ny;
                            }
                        }
                    }
                }
            }

            // 3. 边界碰撞与渲染
            blocks.forEach(block => {
                if (!block.isHovered) {
                    let hit = false;
                    
                    // 左右边界
                    if (block.x <= 0) {
                        block.x = 0;
                        block.dx = Math.abs(block.dx); // 强制向右
                        hit = true;
                    } else if (block.x + block.width >= width) {
                        block.x = width - block.width;
                        block.dx = -Math.abs(block.dx); // 强制向左
                        hit = true;
                    }

                    // 上下边界
                    if (block.y <= 0) {
                        block.y = 0;
                        block.dy = Math.abs(block.dy); // 强制向下
                        hit = true;
                    } else if (block.y + block.height >= height) {
                        block.y = height - block.height;
                        block.dy = -Math.abs(block.dy); // 强制向上
                        hit = true;
                    }

                    if (hit) triggerGlow(block);
                }

                // 渲染
                const scale = block.isHovered ? 1.1 : 1.0;
                block.el.style.transform = `translate(${block.x}px, ${block.y}px) scale(${scale})`;
            });

            requestAnimationFrame(animate);
        }

        // 触发发光效果
        function triggerGlow(block) {
            block.el.classList.add('hit-glow');
            
            // 如果已有定时器，清除它（重置发光时间）
            if (block.glowTimer) {
                clearTimeout(block.glowTimer);
            }

            // 300ms 后移除发光
            block.glowTimer = setTimeout(() => {
                block.el.classList.remove('hit-glow');
                block.glowTimer = null;
            }, 300);
        }

        // 窗口大小改变时重置边界防止溢出
        window.addEventListener('resize', () => {
            const containerRect = playground.getBoundingClientRect();
            blocks.forEach(block => {
                if (block.x > containerRect.width - block.width) block.x = containerRect.width - block.width;
                if (block.y > containerRect.height - block.height) block.y = containerRect.height - block.height;
            });
        });

        // 启动
        // 稍微延迟确保布局完成
        setTimeout(() => {
            initBlocks();
            animate();
        }, 100);

    </script>
    <!-- 复用主页的彩蛋逻辑 -->
    <script src="../easterEgg.js"></script>
</body>
</html>