<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameTime! | DawnTilDusk</title>
    <!-- 引入 Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 引入主样式表 (复用背景和基础风格) -->
    <link rel="stylesheet" href="../styles.css">
    <style>
        /* 页面特定样式 */
        body {
            overflow: hidden; /* 防止滚动条出现 */
        }

        /* 游戏容器：占据剩余空间 */
        #game-playground {
            position: relative;
            width: 100%;
            height: calc(100vh - 240px); /* 增加底部留白，保持视觉对称 */
            margin-top: 20px;
            /* 可选：给容器加一个极其微弱的边框或背景，让它看起来像个“池子” */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        /* 浮动方块样式 */
        .game-block {
            position: absolute;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7); /* 默认文字颜色较暗 */
            background: rgba(255, 255, 255, 0.05); /* 默认背景非常透明 */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(4px);
            transition: background 0.3s, color 0.3s, box-shadow 0.1s, transform 0.1s;
            cursor: pointer;
            user-select: none;
            text-align: center;
            padding: 10px;
        }

        .game-block i {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .game-block span {
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* 鼠标悬停效果 (用户主动交互) - 保持与其他高光时刻一致 */
        .game-block:hover {
            background: rgba(255, 255, 255, 0.3); /* 稍微更亮一点 */
            border-color: rgba(255, 255, 255, 0.8);
            color: white;
            z-index: 100; /* 确保在最上层 */
            /* transform 由 JS 控制 */
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6); /* 强烈发光 */
        }

        .game-block:hover i {
            opacity: 1;
        }

        /* 碰撞发光效果 (JavaScript控制) */
        .game-block.hit-glow {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            color: white;
        }

        /* 适配移动端 */
        @media (max-width: 768px) {
            .game-block {
                width: 90px;
                height: 90px;
            }
            .game-block i {
                font-size: 1.5rem;
            }
            .game-block span {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="container-inner">
                <nav>
                    <!-- Logo链接回主页 -->
                    <a href="../index.html" class="logo">DawnTilDusk | GamingTime!</a>
                    <ul class="nav-links">
                        <!-- 保持导航一致性，当前页高亮或不可点 -->
                        <li><a href="#" style="color: #efe8cb; border-bottom: 2px solid #efe8cb;">Games</a></li>
                        <li><a href="#">002</a></li>
                        <li><a href="#" id="easterEgg">003</a></li>
                        <li><a href="#">004</a></li>
                        <li><a href="#">005</a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <main>
            <!-- 游戏物理容器 -->
            <div id="game-playground">
                <!-- 方块将由JS动态生成 -->
            </div>
        </main>
    </div>

    <!-- 脚本逻辑 -->
    <script>
        // ================= 配置区域 =================
        // 在这里添加你的新游戏！
        const games = [
            {
                id: 'satire-runner',
                name: 'Satire Runner',
                icon: 'fa-person-running', // FontAwesome 图标名
                url: '../satire-runner/',   // 游戏链接
                color: '#4caf50'            // 暂时没用到，可用于特定发光色
            },
            // 示例：未来添加新游戏只需解开注释并修改
            {
                id: 'ticket-001',
                name: 'Ticket 001',
                icon: 'fa-ticket',
                url: 'https://dawntildusk.github.io/ticket001/',
                color: '#ff5722'
            },
            {
                id: 'plane-panel',
                name: 'Plane panel',
                icon: 'fa-plane-departure',
                url: 'https://dawntildusk.github.io/plane-panel/',
                color: '#ff5722'
            },
            {
                id: 'eastereggs-as-well',
                name: 'Aha',
                icon: 'fa-face-laugh-squint',
                url: 'https://v.qq.com/txp/iframe/player.html?vid=s3233ejju5y&auto=1&mute=1',
                color: '#ff5722'
            },
            {
                id: 'nah',
                name: 'Gaming Wonderland',
                icon: 'fa-gamepad',
                url: '#',
                color: '#ff5722'
            },
        ];
        // ===========================================

        const playground = document.getElementById('game-playground');
        const blocks = [];

        // 全局拖拽状态
        let activeDragBlock = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let dragStartX = 0; // 记录拖拽起始点，用于区分点击
        let dragStartY = 0;
        let hasMoved = false; // 标记是否发生过有效移动
        
        // 用于计算投掷速度
        let lastMouseX = 0;
        let lastMouseY = 0;
        let lastTime = 0;
        let dragVelocityX = 0;
        let dragVelocityY = 0;

        // 初始化游戏方块
        function initBlocks() {
            const containerRect = playground.getBoundingClientRect();
            
            games.forEach((game, index) => {
                const el = document.createElement('a');
                el.href = game.url;
                el.className = 'game-block';
                el.innerHTML = `<i class="fas ${game.icon}"></i><span>${game.name}</span>`;
                
                playground.appendChild(el);

                // 随机初始位置 (避免贴边)
                // 注意：el.offsetWidth 在添加到DOM后才可用
                const w = 120; // 估算宽度，或在下一帧获取
                const h = 120;
                const maxX = containerRect.width - w;
                const maxY = containerRect.height - h;

                const x = Math.random() * (maxX - 20) + 10;
                const y = Math.random() * (maxY - 20) + 10;

                // 随机速度 (px/frame)
                // 速度范围：1 ~ 3
                const speed = 1.5; 
                const angle = Math.random() * Math.PI * 2;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;

                blocks.push({
                    el: el,
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy,
                    width: w,
                    height: h,
                    glowTimer: null,
                    isHovered: false, // 新增状态
                    isDragging: false // 新增状态：右键拖拽
                });

                // 禁用原生拖拽，防止拖出网址
                el.setAttribute('draggable', 'false');
                el.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });

                // 绑定鼠标事件
                el.addEventListener('mouseenter', () => {
                    const block = blocks[index]; 
                    block.isHovered = true;
                });
                
                el.addEventListener('mouseleave', () => {
                     const block = blocks[index];
                     block.isHovered = false;
                });

                // 拦截点击事件：如果是拖拽结束，阻止跳转
                el.addEventListener('click', (e) => {
                    if (hasMoved) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });

                // 左键按下准备拖拽
                el.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 0 是左键
                        const block = blocks[index];
                        activeDragBlock = block;
                        
                        hasMoved = false;
                        block.isDragging = false; // 先不标记为拖拽中
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        
                        // 计算鼠标相对于方块左上角的偏移
                        const rect = block.el.getBoundingClientRect();
                        const containerRect = playground.getBoundingClientRect();
                        
                        // 鼠标在 playground 内的相对坐标
                        const mouseX = e.clientX - containerRect.left;
                        const mouseY = e.clientY - containerRect.top;
                        
                        dragOffsetX = mouseX - block.x;
                        dragOffsetY = mouseY - block.y;
                        
                        // 重置速度追踪
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        lastTime = performance.now();
                        dragVelocityX = 0;
                        dragVelocityY = 0;
                    }
                });
            });

            // 全局鼠标事件处理拖拽移动和释放
            window.addEventListener('mousemove', (e) => {
                if (activeDragBlock) {
                    // 判断是否超过阈值，防止误触
                    if (!hasMoved) {
                        const dist = Math.sqrt(Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2));
                        if (dist > 5) {
                            hasMoved = true;
                            activeDragBlock.isDragging = true;
                        }
                    }

                    if (hasMoved) {
                        const containerRect = playground.getBoundingClientRect();
                        const mouseX = e.clientX - containerRect.left;
                        const mouseY = e.clientY - containerRect.top;

                        // 更新方块位置
                        activeDragBlock.x = mouseX - dragOffsetX;
                        activeDragBlock.y = mouseY - dragOffsetY;

                        // 计算实时速度 (用于投掷)
                        const now = performance.now();
                        const dt = now - lastTime;
                        if (dt > 0) {
                            const dx = e.clientX - lastMouseX;
                            const dy = e.clientY - lastMouseY;
                            
                            // 平滑处理：简单的低通滤波，或者直接用瞬时速度
                            // 这里直接用瞬时速度，稍微限制一下最大值防止飞太快
                            // 注意：我们需要的速度单位是 px/frame，假设 60fps，dt 约 16ms
                            // dx/dt 是 px/ms -> px/frame = (dx/dt) * 16.6
                            dragVelocityX = (dx / dt) * 16.6;
                            dragVelocityY = (dy / dt) * 16.6;
                            
                            lastMouseX = e.clientX;
                            lastMouseY = e.clientY;
                            lastTime = now;
                        }
                    }
                }
            });

            // 封装释放逻辑
            function releaseBlock() {
                if (activeDragBlock) {
                    if (hasMoved) {
                        // 应用投掷速度
                        // 1. 增加阻尼系数 (0.25)，让投掷感觉更"重"
                        const damping = 0.25;
                        let throwVx = dragVelocityX * damping;
                        let throwVy = dragVelocityY * damping;

                        // 2. 限制最大速度 (Cap) 降至 8
                        const maxSpeed = 8;
                        activeDragBlock.dx = Math.max(-maxSpeed, Math.min(maxSpeed, throwVx));
                        activeDragBlock.dy = Math.max(-maxSpeed, Math.min(maxSpeed, throwVy));
                    }
                    
                    activeDragBlock.isDragging = false;
                    activeDragBlock = null;
                }
            }

            window.addEventListener('mouseup', (e) => {
                if (activeDragBlock && e.button === 0) {
                    releaseBlock();
                }
            });

            // 修复 Bug：如果鼠标拖出窗口，视为完成投掷
            window.addEventListener('mouseleave', () => {
                if (activeDragBlock) {
                    releaseBlock();
                }
            });
        }

        // 物理循环
        function animate() {
            const containerRect = playground.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;

            // 1. 更新所有非拖拽方块的位置 (悬停不再冻结)
            const baseSpeed = 1.5;
            blocks.forEach(block => {
                // 只有拖拽时才完全由鼠标控制，悬停时继续物理运动
                if (!block.isDragging) {
                    // --- 速度恢复逻辑 (恒定减速) ---
                    // 计算当前合速度
                    const currentSpeed = Math.sqrt(block.dx * block.dx + block.dy * block.dy);
                    
                    // 如果速度超过基准速度，施加恒定阻尼使其恢复
                    if (currentSpeed > baseSpeed) {
                        // 恒定减速 (Linear Deceleration)
                        // 假设 5秒(300帧) 内从 Max(8) 减到 Base(1.5)，差值 6.5
                        // 每帧减速约 6.5 / 300 ≈ 0.02
                        // 为了效果明显一点，我们设为 0.05 (约2秒恢复)
                        const friction = 0.05; 
                        
                        let newSpeed = currentSpeed - friction;
                        if (newSpeed < baseSpeed) newSpeed = baseSpeed;
                        
                        // 保持方向，更新大小
                        const ratio = newSpeed / currentSpeed;
                        block.dx *= ratio;
                        block.dy *= ratio;
                    }
                    // -------------------

                    block.x += block.dx;
                    block.y += block.dy;
                }
            });

            // 2. 方块间的碰撞检测 (双循环避免重复)
            for (let i = 0; i < blocks.length; i++) {
                for (let j = i + 1; j < blocks.length; j++) {
                    const b1 = blocks[i];
                    const b2 = blocks[j];

                    // 只有拖拽时才视为“静止/无限质量”
                    if (b1.isDragging && b2.isDragging) continue;

                    // 简单的 AABB 碰撞检测 (轴对齐包围盒)
                    // 如果需要更精确的圆形碰撞（考虑到方块旋转视觉上可能像圆），可以用距离公式
                    // 这里我们用距离公式模拟“圆形”弹性碰撞，效果更自然
                    // 假设碰撞半径略小于方块宽度的一半 (60px)
                    const radius = 60; 
                    const dx = (b1.x + b1.width/2) - (b2.x + b2.width/2);
                    const dy = (b1.y + b1.height/2) - (b2.y + b2.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < radius * 2) {
                        // === 发生碰撞 ===
                        
                        // 1. 触发发光
                        triggerGlow(b1);
                        triggerGlow(b2);

                        // 2. 物理计算
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const overlap = radius * 2 - distance;

                        // 分情况处理质量
                        // 拖拽中的方块也被视为无限质量
                        const b1Infinite = b1.isHovered || b1.isDragging;
                        const b2Infinite = b2.isHovered || b2.isDragging;

                        if (b1Infinite) {
                            // b1 是墙 (无限质量)，b2 反弹
                            // 位置修正：只移 b2
                            b2.x -= nx * overlap;
                            b2.y -= ny * overlap;

                            // 速度反射：v2' = v2 - 2 * dot(v2, n) * n
                            // 注意：这里的法线 n 是从 b2 指向 b1 的反方向，或者直接用上面的 nx, ny (从 b2 指向 b1 是 -nx, -ny)
                            // 让我们简单点：相对速度 v_rel = v2 - v1(0) = v2
                            // 碰撞冲量仅作用于 b2
                            // 镜面反射公式
                            const dot = b2.dx * nx + b2.dy * ny;
                            b2.dx -= 2 * dot * nx;
                            b2.dy -= 2 * dot * ny;

                        } else if (b2.isHovered) {
                            // b2 是墙 (无限质量)，b1 反弹
                            // 位置修正：只移 b1
                            b1.x += nx * overlap;
                            b1.y += ny * overlap;

                            // 速度反射
                            const dot = b1.dx * nx + b1.dy * ny;
                            b1.dx -= 2 * dot * nx;
                            b1.dy -= 2 * dot * ny;

                        } else {
                            // 双方都是普通质量 (完全弹性碰撞)
                            
                            // 分离重叠部分 (各退一半)
                            const separationX = nx * overlap * 0.5;
                            const separationY = ny * overlap * 0.5;
                            
                            b1.x += separationX;
                            b1.y += separationY;
                            b2.x -= separationX;
                            b2.y -= separationY;

                            // 交换法线方向的速度分量
                            const dvx = b1.dx - b2.dx;
                            const dvy = b1.dy - b2.dy;
                            const dotProduct = dvx * nx + dvy * ny;

                            // 只有当它们相互靠近时才反弹
                            if (dotProduct < 0) {
                                b1.dx -= dotProduct * nx;
                                b1.dy -= dotProduct * ny;
                                b2.dx += dotProduct * nx;
                                b2.dy += dotProduct * ny;
                            }
                        }
                    }
                }
            }

            // 3. 边界碰撞与渲染
            blocks.forEach(block => {
                if (!block.isHovered) {
                    let hit = false;
                    
                    // 左右边界
                    if (block.x <= 0) {
                        block.x = 0;
                        block.dx = Math.abs(block.dx); // 强制向右
                        hit = true;
                    } else if (block.x + block.width >= width) {
                        block.x = width - block.width;
                        block.dx = -Math.abs(block.dx); // 强制向左
                        hit = true;
                    }

                    // 上下边界
                    if (block.y <= 0) {
                        block.y = 0;
                        block.dy = Math.abs(block.dy); // 强制向下
                        hit = true;
                    } else if (block.y + block.height >= height) {
                        block.y = height - block.height;
                        block.dy = -Math.abs(block.dy); // 强制向上
                        hit = true;
                    }

                    if (hit) triggerGlow(block);
                }

                // 渲染
                // 拖拽时稍微放大一点以示区别
                const scale = block.isDragging ? 1.05 : 1.0; 
                block.el.style.transform = `translate(${block.x}px, ${block.y}px) scale(${scale})`;
                // 拖拽时层级最高
                if (block.isDragging) {
                    block.el.style.zIndex = 1000;
                } else {
                    block.el.style.zIndex = "";
                }
            });

            requestAnimationFrame(animate);
        }

        // 触发发光效果
        function triggerGlow(block) {
            block.el.classList.add('hit-glow');
            
            // 如果已有定时器，清除它（重置发光时间）
            if (block.glowTimer) {
                clearTimeout(block.glowTimer);
            }

            // 300ms 后移除发光
            block.glowTimer = setTimeout(() => {
                block.el.classList.remove('hit-glow');
                block.glowTimer = null;
            }, 300);
        }

        // 窗口大小改变时重置边界防止溢出
        window.addEventListener('resize', () => {
            const containerRect = playground.getBoundingClientRect();
            blocks.forEach(block => {
                if (block.x > containerRect.width - block.width) block.x = containerRect.width - block.width;
                if (block.y > containerRect.height - block.height) block.y = containerRect.height - block.height;
            });
        });

        // 启动
        // 稍微延迟确保布局完成
        setTimeout(() => {
            initBlocks();
            animate();
        }, 100);

    </script>
    <!-- 复用主页的彩蛋逻辑 -->
    <script src="../easterEgg.js"></script>
</body>
</html>