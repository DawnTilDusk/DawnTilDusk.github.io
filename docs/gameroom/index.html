<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameTime! | DawnTilDusk</title>
    <!-- 引入 Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- 引入主样式表 (复用背景和基础风格) -->
    <link rel="stylesheet" href="../styles.css">
    <style>
        /* 页面特定样式 */
        :root {
            /* 核心控制变量：调整此处数值来改变游戏区域大小 */
            --playground-offset-bottom: 270px; /* 底部留白高度 */
        }

        body {
            overflow: hidden; /* 防止滚动条出现 */
        }

        /* 游戏容器：占据剩余空间 */
        #game-playground {
            position: relative;
            width: 100%;
            height: calc(100vh - var(--playground-offset-bottom)); /* 增加底部留白，保持视觉对称 */
            margin-top: 20px;
            /* 可选：给容器加一个极其微弱的边框或背景，让它看起来像个“池子” */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        /* 浮动方块样式 */
        .game-block {
            position: absolute;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7); /* 默认文字颜色较暗 */
            background: rgba(255, 255, 255, 0.05); /* 默认背景非常透明 */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(4px);
            transition: background 0.3s, color 0.3s, box-shadow 0.1s, transform 0.1s;
            cursor: pointer;
            user-select: none;
            text-align: center;
            padding: 10px;
        }

        .game-block i {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .game-block span {
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* 鼠标悬停效果 (用户主动交互) - 保持与其他高光时刻一致 */
        .game-block:hover {
            background: rgba(255, 255, 255, 0.3); /* 稍微更亮一点 */
            border-color: rgba(255, 255, 255, 0.8);
            color: white;
            z-index: 100; /* 确保在最上层 */
            /* transform 由 JS 控制 */
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6); /* 强烈发光 */
        }

        .game-block:hover i {
            opacity: 1;
        }

        /* 碰撞发光效果 (JavaScript控制) */
        .game-block.hit-glow {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            color: white;
        }

        /* 适配移动端 */
        @media (max-width: 768px) {
            .game-block {
                width: 90px;
                height: 90px;
            }
            .game-block i {
                font-size: 1.5rem;
            }
            .game-block span {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="container-inner">
                <nav>
                    <!-- Logo链接回主页 -->
                    <a href="../index.html" class="logo">DawnTilDusk | GamingTime!</a>
                    <ul class="nav-links">
                        <!-- 保持导航一致性，当前页高亮或不可点 -->
                        <li><a href="#" style="color: #efe8cb; border-bottom: 2px solid #efe8cb;">Games</a></li>
                        <li><a href="#">About</a></li>
                        <li><a href="#" id="easterEgg">Anything</a></li>
                        <li><a href="#">Contact</a></li>
                        <li><a href="#">Tools</a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <main>
            <!-- 游戏物理容器 -->
            <div id="game-playground">
                <!-- 方块将由JS动态生成 -->
            </div>
        </main>
    </div>

    <!-- 脚本逻辑 -->
    <script>
        // ================= 配置区域 =================
        // 在这里添加你的新游戏！
        const games = [
            {
                id: 'satire-runner',
                name: 'Satire Runner',
                icon: 'fa-person-running', // FontAwesome 图标名
                url: '../satire-runner/',   // 游戏链接
                color: '#4caf50'            // 暂时没用到，可用于特定发光色
            },
            // 示例：未来添加新游戏只需解开注释并修改
            {
                id: 'ticket-001',
                name: 'Ticket 001',
                icon: 'fa-ticket',
                url: 'https://dawntildusk.github.io/ticket001/',
                color: '#ff5722'
            },
            {
                id: 'plane-panel',
                name: 'Plane panel',
                icon: 'fa-plane-departure',
                url: 'https://dawntildusk.github.io/plane-panel/',
                color: '#ff5722'
            },
            {
                id: 'eastereggs-as-well',
                name: 'Aha',
                icon: 'fa-face-laugh-squint',
                url: '#',
                action: 'easterEgg',
                color: '#ff5722'
            },
            {
                id: 'nah',
                name: 'Gaming Wonderland',
                icon: 'fa-gamepad',
                url: '#',
                action: 'easterEgg',
                color: '#ff5722'
            },
            {
                id: 'lab-monitor',
                name: 'Lab Monitor',
                icon: 'fa-desktop',
                url: 'https://dawntildusk.github.io/lab-monitor/',
                color: '#ff5722'
            }
        ];
        // ===========================================

        const playground = document.getElementById('game-playground');
        const blocks = [];

        // 全局拖拽状态
        let activeDragBlock = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let dragStartX = 0; // 记录拖拽起始点，用于区分点击
        let dragStartY = 0;
        let hasMoved = false; // 标记是否发生过有效移动
        
        // 用于计算投掷速度
        let lastMouseX = 0;
        let lastMouseY = 0;
        let lastTime = 0;
        let dragVelocityX = 0;
        let dragVelocityY = 0;

        // ================= 音效系统 =================
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // 播放清脆的碰撞声 (Ping)
        // frequency: 基础频率，默认 880Hz (A5)
        function playCollisionSound(frequency = 880) {
            if (!audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'sine'; // 正弦波最清脆
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            
            // 快速衰减模拟敲击声
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); // 初始音量
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3); // 0.3秒内衰减

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }

        // 播放沙沙的撞墙声 (Noise)
        function playWallSound() {
            // 检查全局音效设置
            const audioEnabled = localStorage.getItem('dawn_til_dusk_game_audio');
            // 如果设置为 false 则不播放 (注意：null 默认为 true)
            if (audioEnabled === 'false') return;

            if (!audioCtx) return;

            // 创建白噪声 buffer
            const bufferSize = audioCtx.sampleRate * 0.1; // 0.1秒
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;

            const gainNode = audioCtx.createGain();
            // 低音量，柔和一点
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            // 简单的低通滤波器，让声音更闷（像撞到软垫）
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            noiseSource.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            noiseSource.start();
        }
        // ===========================================

        // 初始化游戏方块
        function initBlocks() {
            // 初始化音频上下文 (用户交互后才能播放)
            document.addEventListener('click', initAudio, { once: true });

            const containerRect = playground.getBoundingClientRect();
            
            games.forEach((game, index) => {
                const el = document.createElement('a');
                el.href = game.url;
                el.className = 'game-block';
                el.innerHTML = `<i class="fas ${game.icon}"></i><span>${game.name}</span>`;
                
                playground.appendChild(el);

                // 随机初始位置 (避免贴边)
                // 注意：el.offsetWidth 在添加到DOM后才可用
                const w = 120; // 估算宽度，或在下一帧获取
                const h = 120;
                const maxX = containerRect.width - w;
                const maxY = containerRect.height - h;

                const x = Math.random() * (maxX - 20) + 10;
                const y = Math.random() * (maxY - 20) + 10;

                // 随机速度 (px/frame)
                // 速度范围：1 ~ 3
                const speed = 1.5; 
                const angle = Math.random() * Math.PI * 2;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;

                blocks.push({
                    el: el,
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy,
                    width: w,
                    height: h,
                    glowTimer: null,
                    lastHitTime: 0, // 新增：用于音效冷却
                    isHovered: false, // 新增状态
                    isDragging: false // 新增状态：右键拖拽
                });

                // 禁用原生拖拽，防止拖出网址
                el.setAttribute('draggable', 'false');
                el.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });

                // 绑定鼠标事件
                el.addEventListener('mouseenter', () => {
                    const block = blocks[index]; 
                    block.isHovered = true;
                });
                
                el.addEventListener('mouseleave', () => {
                     const block = blocks[index];
                     block.isHovered = false;
                });

                // 拦截点击事件：如果是拖拽结束，阻止跳转；如果是彩蛋方块，触发彩蛋
                el.addEventListener('click', (e) => {
                    if (hasMoved) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    
                    if (game.action === 'easterEgg') {
                        e.preventDefault();
                        if (window.triggerEasterEgg) {
                            window.triggerEasterEgg();
                        }
                    }
                });

                // 左键按下准备拖拽
                el.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // 0 是左键
                        e.preventDefault(); // 防止选中文本等默认行为，确保 mouseup 能触发
                        const block = blocks[index];
                        activeDragBlock = block;
                        
                        hasMoved = false;
                        block.isDragging = false; // 先不标记为拖拽中
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                        
                        // 计算鼠标相对于方块左上角的偏移
                        const rect = block.el.getBoundingClientRect();
                        const containerRect = playground.getBoundingClientRect();
                        
                        // 鼠标在 playground 内的相对坐标
                        const mouseX = e.clientX - containerRect.left;
                        const mouseY = e.clientY - containerRect.top;
                        
                        dragOffsetX = mouseX - block.x;
                        dragOffsetY = mouseY - block.y;
                        
                        // 重置速度追踪
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        lastTime = performance.now();
                        dragVelocityX = 0;
                        dragVelocityY = 0;
                    }
                });
            });

            // 全局鼠标事件处理拖拽移动和释放
            window.addEventListener('mousemove', (e) => {
                if (activeDragBlock) {
                    // 安全检查：如果此时没有按住左键 (buttons & 1 应该为真)，说明错过了 mouseup，强制释放
                    if ((e.buttons & 1) === 0) {
                        releaseBlock();
                        return;
                    }

                    // 判断是否超过阈值，防止误触
                    if (!hasMoved) {
                        const dist = Math.sqrt(Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2));
                        if (dist > 5) {
                            hasMoved = true;
                            activeDragBlock.isDragging = true;
                        }
                    }

                    if (hasMoved) {
                        const containerRect = playground.getBoundingClientRect();
                        const mouseX = e.clientX - containerRect.left;
                        const mouseY = e.clientY - containerRect.top;

                        // 更新方块位置 (加入边界限制)
                        let newX = mouseX - dragOffsetX;
                        let newY = mouseY - dragOffsetY;

                        // 限制 X 轴
                        if (newX < 0) newX = 0;
                        if (newX > containerRect.width - activeDragBlock.width) newX = containerRect.width - activeDragBlock.width;

                        // 限制 Y 轴
                        if (newY < 0) newY = 0;
                        if (newY > containerRect.height - activeDragBlock.height) newY = containerRect.height - activeDragBlock.height;

                        activeDragBlock.x = newX;
                        activeDragBlock.y = newY;

                        // 计算实时速度 (用于投掷)
                        const now = performance.now();
                        const dt = now - lastTime;
                        if (dt > 0) {
                            const dx = e.clientX - lastMouseX;
                            const dy = e.clientY - lastMouseY;
                            
                            // 平滑处理：简单的低通滤波，或者直接用瞬时速度
                            // 这里直接用瞬时速度，稍微限制一下最大值防止飞太快
                            // 注意：我们需要的速度单位是 px/frame，假设 60fps，dt 约 16ms
                            // dx/dt 是 px/ms -> px/frame = (dx/dt) * 16.6
                            dragVelocityX = (dx / dt) * 16.6;
                            dragVelocityY = (dy / dt) * 16.6;
                            
                            lastMouseX = e.clientX;
                            lastMouseY = e.clientY;
                            lastTime = now;
                        }
                    }
                }
            });

            // 封装释放逻辑
            function releaseBlock() {
                if (activeDragBlock) {
                    if (hasMoved) {
                        // 应用投掷速度
                        // 1. 增加阻尼系数 (0.25)，让投掷感觉更"重"
                        const damping = 0.25;
                        let throwVx = dragVelocityX * damping;
                        let throwVy = dragVelocityY * damping;

                        // 2. 限制最大速度 (Cap) 降至 8
                        const maxSpeed = 8;
                        activeDragBlock.dx = Math.max(-maxSpeed, Math.min(maxSpeed, throwVx));
                        activeDragBlock.dy = Math.max(-maxSpeed, Math.min(maxSpeed, throwVy));
                    }
                    
                    activeDragBlock.isDragging = false;
                    activeDragBlock = null;
                }
            }

            window.addEventListener('mouseup', (e) => {
                if (activeDragBlock && e.button === 0) {
                    releaseBlock();
                }
            });

            // 修复 Bug：如果鼠标拖出窗口，视为完成投掷
            window.addEventListener('mouseleave', () => {
                if (activeDragBlock) {
                    releaseBlock();
                }
            });
        }

        // 物理循环
        function animate() {
            const containerRect = playground.getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;

            // 1. 更新所有非拖拽方块的位置 (悬停不再冻结)
            const baseSpeed = 1.5;
            blocks.forEach(block => {
                // 只有拖拽时才完全由鼠标控制，悬停时继续物理运动
                if (!block.isDragging) {
                    // --- 速度恢复与维持逻辑 ---
                    // 计算当前合速度
                    let currentSpeed = Math.sqrt(block.dx * block.dx + block.dy * block.dy);
                    
                    // 防止速度过小导致卡住或持续触发碰撞
                    // 如果速度几乎为0 (例如 < 0.1)，给一个随机方向的最小速度
                    if (currentSpeed < 0.1) {
                        const angle = Math.random() * Math.PI * 2;
                        block.dx = Math.cos(angle) * baseSpeed;
                        block.dy = Math.sin(angle) * baseSpeed;
                        currentSpeed = baseSpeed;
                    }

                    // 1. 限制最大速度 (减速)
                    if (currentSpeed > baseSpeed) {
                        // 恒定减速 (Linear Deceleration)
                        const friction = 0.05; 
                        let newSpeed = currentSpeed - friction;
                        if (newSpeed < baseSpeed) newSpeed = baseSpeed;
                        
                        const ratio = newSpeed / currentSpeed;
                        block.dx *= ratio;
                        block.dy *= ratio;
                    } 
                    // 2. 维持最小速度 (加速)
                    // 如果速度小于基准值，缓慢加速恢复，保证方块始终有活力
                    else if (currentSpeed < baseSpeed) {
                        const acceleration = 0.02;
                        let newSpeed = currentSpeed + acceleration;
                        if (newSpeed > baseSpeed) newSpeed = baseSpeed;

                        const ratio = newSpeed / currentSpeed;
                        block.dx *= ratio;
                        block.dy *= ratio;
                    }
                    // -------------------

                    block.x += block.dx;
                    block.y += block.dy;
                }
            });

            // 2. 方块间的碰撞检测 (双循环避免重复)
            for (let i = 0; i < blocks.length; i++) {
                for (let j = i + 1; j < blocks.length; j++) {
                    const b1 = blocks[i];
                    const b2 = blocks[j];

                    // 只有拖拽时才视为“静止/无限质量”
                    if (b1.isDragging && b2.isDragging) continue;

                    // === AABB 碰撞检测 (轴对齐包围盒) ===
                    // 解决方块重叠和碰撞箱不准确的问题
                    
                    // 计算各轴重叠量
                    // b1 center: b1.x + b1.width/2
                    // b1 half width: b1.width/2
                    const b1HalfW = b1.width / 2;
                    const b1HalfH = b1.height / 2;
                    const b2HalfW = b2.width / 2;
                    const b2HalfH = b2.height / 2;

                    const b1CenterX = b1.x + b1HalfW;
                    const b1CenterY = b1.y + b1HalfH;
                    const b2CenterX = b2.x + b2HalfW;
                    const b2CenterY = b2.y + b2HalfH;

                    const dx = b1CenterX - b2CenterX;
                    const dy = b1CenterY - b2CenterY;

                    const combinedHalfW = b1HalfW + b2HalfW;
                    const combinedHalfH = b1HalfH + b2HalfH;

                    // 检查是否重叠
                    if (Math.abs(dx) < combinedHalfW && Math.abs(dy) < combinedHalfH) {
                        // === 发生碰撞 ===
                        
                        // 1. 触发发光
                        triggerGlow(b1);
                        triggerGlow(b2);

                        // 播放碰撞音效 (清脆的声音)
                        // 冷却检查：只要有一方不在冷却中就播放
                        const now = performance.now();
                        if (now - b1.lastHitTime > 150 || now - b2.lastHitTime > 150) {
                            playCollisionSound(); // 使用清脆的 Ping 声
                            b1.lastHitTime = now;
                            b2.lastHitTime = now;
                        }

                        // 2. 物理计算 (AABB 分离与反弹)
                        
                        // 计算重叠深度
                        const overlapX = combinedHalfW - Math.abs(dx);
                        const overlapY = combinedHalfH - Math.abs(dy);

                        // 确定碰撞法线 (最小穿透轴)
                        let nx = 0, ny = 0;
                        if (overlapX < overlapY) {
                            // X轴碰撞
                            nx = dx > 0 ? 1 : -1;
                            // 分离位置
                            const separation = overlapX;
                             // 分情况处理质量
                            const b1Infinite = b1.isHovered || b1.isDragging;
                            const b2Infinite = b2.isHovered || b2.isDragging;

                            if (b1Infinite) {
                                b2.x -= nx * separation;
                                b2.dx *= -1; // 简单反弹
                            } else if (b2Infinite) {
                                b1.x += nx * separation;
                                b1.dx *= -1;
                            } else {
                                b1.x += nx * separation * 0.5;
                                b2.x -= nx * separation * 0.5;
                                // 交换速度 (简化弹性碰撞)
                                const temp = b1.dx;
                                b1.dx = b2.dx;
                                b2.dx = temp;
                            }
                        } else {
                            // Y轴碰撞
                            ny = dy > 0 ? 1 : -1;
                            const separation = overlapY;
                             // 分情况处理质量
                            const b1Infinite = b1.isHovered || b1.isDragging;
                            const b2Infinite = b2.isHovered || b2.isDragging;

                            if (b1Infinite) {
                                b2.y -= ny * separation;
                                b2.dy *= -1;
                            } else if (b2Infinite) {
                                b1.y += ny * separation;
                                b1.dy *= -1;
                            } else {
                                b1.y += ny * separation * 0.5;
                                b2.y -= ny * separation * 0.5;
                                // 交换速度
                                const temp = b1.dy;
                                b1.dy = b2.dy;
                                b2.dy = temp;
                            }
                        }
                    }
                }
            }

            // 3. 边界碰撞与渲染
            blocks.forEach(block => {
                // 始终进行边界检查，防止鼠标悬停时飞出界外
                let hit = false;
                
                // 左右边界
                if (block.x <= 0) {
                    block.x = 0;
                    block.dx = Math.abs(block.dx); // 强制向右
                    hit = true;
                } else if (block.x + block.width >= width) {
                    block.x = width - block.width;
                    block.dx = -Math.abs(block.dx); // 强制向左
                    hit = true;
                }

                // 上下边界
                if (block.y <= 0) {
                    block.y = 0;
                    block.dy = Math.abs(block.dy); // 强制向下
                    hit = true;
                } else if (block.y + block.height >= height) {
                    block.y = height - block.height;
                    block.dy = -Math.abs(block.dy); // 强制向上
                    hit = true;
                }

                if (hit) {
                    triggerGlow(block);
                    // 撞墙音效，沙沙声
                    // 增加冷却时间检查 (150ms)，防止贴边持续触发
                    const now = performance.now();
                    if (now - block.lastHitTime > 150) {
                        playWallSound();
                        block.lastHitTime = now;
                    }
                }

                // 渲染
                // 拖拽时稍微放大一点以示区别 (已取消放大，改为仅提升层级)
                const scale = 1.0; 
                block.el.style.transform = `translate(${block.x}px, ${block.y}px) scale(${scale})`;
                // 拖拽时层级最高
                if (block.isDragging) {
                    block.el.style.zIndex = 1000;
                } else {
                    block.el.style.zIndex = "";
                }
            });

            requestAnimationFrame(animate);
        }

        // 触发发光效果
        function triggerGlow(block) {
            block.el.classList.add('hit-glow');
            
            // 如果已有定时器，清除它（重置发光时间）
            if (block.glowTimer) {
                clearTimeout(block.glowTimer);
            }

            // 300ms 后移除发光
            block.glowTimer = setTimeout(() => {
                block.el.classList.remove('hit-glow');
                block.glowTimer = null;
            }, 300);
        }

        // 窗口大小改变时重置边界防止溢出
        window.addEventListener('resize', () => {
            const containerRect = playground.getBoundingClientRect();
            blocks.forEach(block => {
                if (block.x > containerRect.width - block.width) block.x = containerRect.width - block.width;
                if (block.y > containerRect.height - block.height) block.y = containerRect.height - block.height;
            });
        });

        // 启动
        // 稍微延迟确保布局完成
        setTimeout(() => {
            initBlocks();
            animate();
        }, 100);

    </script>
    <!-- 复用主页的彩蛋逻辑 -->
    <script src="../easterEgg.js"></script>
    <!-- 引入粒子特效 -->
    <script src="../clickEffects.js"></script>
</body>
</html>